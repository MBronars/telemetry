\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}

\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO:} #1}}

% lifted from http://timmurphy.org/2014/01/27/displaying-code-in-latex-documents/
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=2, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{green}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red} % string color
}

\title{\textbf{Telemetry Quick Start \& Reference}}
\author{Ducky}
\date{\today}
\begin{document}

\maketitle

\section{Introduction}
The telemetry library is designed to provide a simple and efficient way to get data off an embedded platform and both visualized and logged on a PC. The intended use case is streaming data from an embedded system to a PC through a UART (possibly on top of either a USB or Bluetooth transport layer) interface. Since data definitions are transmitted, user-side code changes can be limited to the data source side, eliminating the need to keep both the source-side and sink-side code in sync.

The server-side (data source) code is written in C++ and designed with embedded constraints in mind (mainly, no dynamic memory alocation is used). Templated classes are used to support most native data types and a hardware abstraction layer allows multiple platforms (including Arduino and mBed) to be supported.

The client-side (data sink) code is written in Python. A basic telemetry protocol parser is provided that separates and interprets telemetry packets and other data from the received stream. A matplotlib-based GUI is provided on top of the parser that visualizes numeric data as a line plot and array-numeric data as a waterfall / spectrogram style plot.

A protocol spec is also provided allowing other implementation of either the server and client. It short, it defines a binary wire format along with packet structures for data and headers.

\section{Prerequisites}
The following software is necessary for a basic telemetry install:
\begin{itemize}
  \item \href{https://www.python.org/downloads/}{Python} (this was tested and written for 3.4, but may work on 2.7)
\end{itemize}

The following software is necessary for the telemetry plotter GUI:
\begin{itemize}
  \item \href{http://sourceforge.net/projects/numpy/files/NumPy/}{NumPy (1.9.2 or later)}
  \begin{itemize}
    \item \href{http://sourceforge.net/projects/numpy/files/NumPy/1.9.2/numpy-1.9.2-win32-superpack-python3.4.exe/download}{executable for Windows, Python 3.4 32-bit}
  \end{itemize}
  \item \href{http://matplotlib.org/downloads.html}{matplotlib (1.4.3 or later)}
  \begin{itemize}
    \item \href{http://sourceforge.net/projects/matplotlib/files/matplotlib/matplotlib-1.4.3/windows/matplotlib-1.4.3.win32-py3.4.exe/download}{executable for Windows, Python 3.4 32-bit}
  \end{itemize}
\end{itemize}

\subsection{Windows Install}
\begin{enumerate}
  \item Install the prerequisite software above.
  \item Install the required Python packages via \texttt{pip}:
  \begin{verbatim}
    cd C:\Python34\Scripts
    pip install pyserial 
  \end{verbatim}
  \item If using the plotter GUI, also install these Python dependencies for matplotlib via \texttt{pip}:
  \begin{verbatim}
    cd C:\Python34\Scripts
    pip install six python-dateutil pyparsing
  \end{verbatim}
\end{enumerate}

\subsection{Linux Install}
\todo{to be written}

\section{Known Issues}
\subsection{Telemetry framework}
\begin{itemize}
  \item None yet
\end{itemize}

\subsection{Plotter GUI}
\begin{itemize}
  \item Waterfall / spectrogram-style plotting is highly inefficient (but serviceable).
\end{itemize}

\subsection{mBed HAL}
\begin{itemize}
  \item MODSERIAL and Serial putc are highly inefficient, and the overhead is noticable at high data rates (at 1 Mbaud, the overhead is about 3x the time to transmit the byte). Using MODDMA may increase efficiency.
\end{itemize}

\subsection{Arduino HAL}
\begin{itemize}
  \item None yet
\end{itemize}

\section{Quick Start Guide}
\subsection{Transmit-side}
All the transmit-side code is contained in (repository base)\texttt{/server-cpp}.
\subsection{Build system setup}
\begin{itemize}
  \item Add all the \texttt{.h} header files to your compiler's include path.
  \item Add all the \texttt{.cpp} source files to your build path - these should end up compiled into your code.
\end{itemize}
\subsection{Code setup}
\begin{itemize}
  \item Include the telemetry header in your code:
  \begin{lstlisting}[language=C++]
#include "telemetry.h"
  \end{lstlisting}
  \item Include the HAL for your platform: either \texttt{telemetry-arduino.h} or \texttt{telemetry-mbed.h}
\end{itemize}
\subsection{Usage}
\begin{itemize}
  \item Instantiate both a telemetry HAL and a \texttt{Telemetry} object: \\
  Arduino example using \texttt{Serial1} as the UART pins:
  \begin{lstlisting}[language=C++]
telemetry::ArduinoHalInterface telemetry_hal(Serial1);
telemetry::Telemetry telemetry_obj(telemetry_hal);
  \end{lstlisting}  
  mBed example using \texttt{PTA2} as UART transmit and \texttt{PTA1} as UART receive:
  \begin{lstlisting}[language=C++]
MODSERIAL telemetry_serial(PTA2, PTA1);
telemetry::MbedHal telemetry_hal(telemetry_serial);
telemetry::Telemetry telemetry_obj(telemetry_hal);
  \end{lstlisting}
  \item Instantiate telemetry data objects:
  \begin{lstlisting}[language=C++]
telemetry::NumericData<uint32_t> time_ms(telemetry_obj, "time", "Time", "ms", 0);
telemetry::NumericData<float> motor_pwm(telemetry_obj, "motor", "Motor PWM", "\%DC", 0);
telemetry::NumericArray<uint16_t, 128> linescan(telemetry_obj, "linescan", "Linescan", "ADC", 0);  
  \end{lstlisting}
  The constructor signatures are:
  \begin{itemize}
    \item \texttt{template <typename T>\\ NumericData(Telemetry\& telemetry\_container, const char* internal\_name, const char* display\_name, const char* units, T init\_value)} \\
    \texttt{NumericData} describes numeric data of type \texttt{T}. Only 8-, 16- and 32-bit integers and single-precision floats are currently supported (but why would you use double-precision on a dinky embedded processor?!).
    \begin{itemize}
      \item \texttt{telemetry\_container}: a reference to a \texttt{Telemetry} object to associate this data with.
      \item \texttt{internal\_name}: a string giving this object an internal name to be referenced in code.
      \item \texttt{display\_name}: a string giving this object a human-friendly name.
      \item \texttt{units}: units this data record is in (not currently used, but may be useful for automation later).
      \item \texttt{init\_value}: initial value.
    \end{itemize}
    \item \texttt{template <typename T, uint32\_t array\_count>\\ NumericArray(Telemetry\& telemetry\_container, const char* internal\_name, const char* display\_name, const char* units, T elem\_init\_value)} \\
    \texttt{NumericArray} describes an array of numeric objects of type \texttt{T}. Same constraints apply as to NumericData. The array size \texttt{array\_count} is constant to avoid dynamic memory allocations.
    \begin{itemize}
      \item \texttt{telemetry\_container}: a reference to a \texttt{Telemetry} object to associate this data with.
      \item \texttt{internal\_name}: a string giving this object an internal name to be referenced in code.
      \item \texttt{display\_name}: a string giving this object a human-friendly name.
      \item \texttt{units}: units this data record is in (not currently used, but may be useful for automation later).
      \item \texttt{elem\_init\_value}: initial value of array elements.
    \end{itemize}
  \end{itemize}
  \item Transmit the data definitions once at the beginning of your code, after you have finished defining all the data.
  \begin{lstlisting}[language=C++]
telemetry_obj.transmit_header();
  \end{lstlisting}
  \item Load data to be transmitted into the telemetry objects. \\
  These objects contain the code necessary to transmit and receive telemetry data, but otherwise behave similarly to their template types. For example, you can use the \texttt{motor\_pwm} object as a float:
  \begin{lstlisting}[language=C++]
PwmOut MotorOutput(PTA4);
...
motor_pwm = 0.2;
MotorOutput.write(motor_pwm);
  \end{lstlisting}
  Writing to the objects flags the new data to be transmitted on the next telemetry IO operation. Note that the code may not be thread-safe.
  \item Regularly call \texttt{Telemetry}'s \texttt{do\_io} operation to transmit any updated data and handle received data.
  \begin{lstlisting}[language=C++]
telemetry_obj.do_io();
  \end{lstlisting}
  \item Note that you may continue to use the UART to transmit other data (like \texttt{printf}s) as long as this is not done during the middle of a \texttt{Telemetry} \texttt{do\_io} operation or contains the start-of-frame sequence (\texttt{0x05 0x39}).
\end{itemize}

\subsection{Receive-side}

That's it.
\end{document}
